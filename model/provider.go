package model

import (
	"bytes"
	"encoding/json"
	"fmt"
	log "github.com/Sirupsen/logrus"
	"net/http"
	"time"
)

type Provider struct {
	ID           string         `json:"id,omitempty" gorethink:"id,omitempty"`
	Name         string         `json:"name" gorethink:"name"`
	Type         string         `json:"type" gorethink:"type"`
	Config       interface{}    `json:"config" gorethink:"config"`
	Url          string         `json:"url" gorethink:"url"`
	ProviderJobs []*ProviderJob `json:"providerJobs" gorethink:"providerJobs"`
	Health       Health         `json:"health" gorethink:"health"`
	client       *http.Client
	//AvailableJobTypes types.Array    `json:"availableJobTypes" gorethink:"availableJobTypes"`
}

func (p *Provider) SendBuild(providerBuild *ProviderBuild) {
	if providerBuild.ProviderJob == nil {
		log.Errorf("ProviderJob in ProviderBuild is nil")
		return
	}

	if providerBuild.ProviderJob.Url == "" {
		log.Error("ProviderJob URL is empty")
		return
	}

	found := false

	for _, job := range p.ProviderJobs {
		if job.Url == providerBuild.ProviderJob.Url && job.Name == providerBuild.ProviderJob.Name {
			found = true
			break
		}
	}
	if !found {
		log.Errorf("Could not find provider job name = %s and url = %s in provider %s list of jobs", providerBuild.ProviderJob.Name, providerBuild.ProviderJob.Url, p.Name)
		return
	}

	data, err := json.Marshal(providerBuild)

	if err != nil {
		log.Errorf("Could not marshal provider build")
		return
	}

	prettyData, err := json.MarshalIndent(providerBuild, "", "  ")

	if err == nil {
		fmt.Println(string(prettyData))
	}

	req, err := http.NewRequest("POST", providerBuild.ProviderJob.Url, bytes.NewBuffer(data))

	req.Header.Set("Content-Type", "application/json")
	// TODO: add auth key that will be generated by provider bridge

	if p.client == nil {
		p.client = &http.Client{}
	}

	resp, err := p.client.Do(req)

	if err != nil {
		log.Errorf("Could not perform provider build request to %s, error = %s", req.URL.String(), err.Error())
		return
	}

	// TODO: do something useful with the response
	if resp.StatusCode != http.StatusAccepted {
		log.Errorf("Received an unexpected return code in provider build request: %d", resp.StatusCode)
	}
	// TODO: make this return something useful to check for errors.
}

func NewProvider(
	name string,
	//availableJobTypes types.Array,
	config interface{},
	url string,
	providerJobs []*ProviderJob,
) *Provider {

	return &Provider{
		Name: name,
		//AvailableJobTypes: availableJobTypes,
		Config:       config,
		Url:          url,
		ProviderJobs: providerJobs,
		client:       &http.Client{},
	}
}

type Health struct {
	Url        string    `json:"url" gorethink:"url"`
	Status     string    `json:"status" gorethink:"status"`
	LastUpdate time.Time `json:"lastUpdate" gorethink:"lastUpdate"`
}

type ProviderJob struct {
	//ID   string `json:"id,omitempty" gorethink:"id,omitempty"`
	Name string `json:"name" gorethink:"name"`
	Url  string `json:"url" gorethink:"url"`
}

func (p *ProviderJob) NewProviderJob(name string) *ProviderJob {

	return &ProviderJob{
		Name: name,
	}
}

type ProviderTask struct {
	Project  *Project
	Test     *Test
	Build    *Build
	Image    *Image
	Registry *Registry
}

func NewProviderTask(
	project *Project,
	test *Test,
	build *Build,
	image *Image,
	registry *Registry,
) *ProviderTask {
	return &ProviderTask{
		Project:  project,
		Test:     test,
		Build:    build,
		Image:    image,
		Registry: registry,
	}
}

type ProviderBuild struct {
	ProviderJob *ProviderJob
	Tasks       []*ProviderTask
}

func NewProviderBuild(providerJob *ProviderJob, tasks []*ProviderTask) *ProviderBuild {
	return &ProviderBuild{
		ProviderJob: providerJob,
		Tasks:       tasks,
	}
}
